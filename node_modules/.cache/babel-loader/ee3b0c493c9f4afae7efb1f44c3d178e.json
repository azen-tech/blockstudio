{"ast":null,"code":"var _regeneratorRuntime = require(\"/home/azen/Documents/blockstudio-main/App/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/azen/Documents/blockstudio-main/App/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar debug = require(\"debug\")(\"contract:handlers\"); // eslint-disable-line no-unused-vars\n\n\nvar StatusError = require(\"./statuserror\");\n\nvar Utils = require(\"./utils\");\n\nvar Reason = require(\"./reason\");\n/*\n  Handlers for events emitted by `send` / `call` etc.\n */\n\n\nvar handlers = {\n  // ----------------------------------- Constants -------------------------------------------------\n  maxConfirmations: 24,\n  // Maximum number of confirmation web3 emits\n  defaultTimeoutBlocks: 50,\n  // Maximum number of blocks web3 will wait before abandoning tx\n  timeoutMessage: \"50 blocks\",\n  // Substring of web3 timeout error.\n  // -----------------------------------  Helpers --------------------------------------------------\n\n  /**\n   * Parses error message and determines if we should squash block timeout errors at user's request.\n   * @param  {Object} context execution state\n   * @param  {Object} error   error\n   * @return {Boolean}\n   */\n  ignoreTimeoutError: function ignoreTimeoutError(context, error) {\n    var timedOut = error.message && error.message.includes(handlers.timeoutMessage);\n    var shouldWait = context.contract && context.contract.timeoutBlocks && context.contract.timeoutBlocks > handlers.defaultTimeoutBlocks;\n    return timedOut && shouldWait;\n  },\n\n  /**\n   * Attaches Truffle specific handlers to all of the events emitted by a web3 method.\n   * @param {Object}       context  execution state\n   * @param {PromiEvent}   emitter  promiEvent returned by a web3 method call\n   */\n  setup: function setup(emitter, context) {\n    emitter.on(\"error\", handlers.error.bind(emitter, context));\n    emitter.on(\"transactionHash\", handlers.hash.bind(emitter, context));\n    emitter.on(\"confirmation\", handlers.confirmation.bind(emitter, context));\n    emitter.on(\"receipt\", handlers.receipt.bind(emitter, context));\n  },\n  // -----------------------------------  Handlers -------------------------------------------------\n\n  /**\n   * Error event handler. Emits error unless error is block timeout and user has\n   * specified we should wait longer\n   * @param  {Object} context   execution state\n   * @param  {Object} error     error\n   */\n  error: function error(context, _error) {\n    if (!handlers.ignoreTimeoutError(context, _error)) {\n      context.promiEvent.eventEmitter.emit(\"error\", _error);\n      this.removeListener(\"error\", handlers.error);\n    }\n  },\n\n  /**\n   * Transaction hash event handler. Attaches the hash to the context object\n   * so it can be attached to the contract instance after a deployment resolves.\n   * @param  {Object} context   execution state\n   * @param  {String} hash      transaction hash\n   */\n  hash: function hash(context, _hash) {\n    context.transactionHash = _hash;\n    context.promiEvent.eventEmitter.emit(\"transactionHash\", _hash);\n    this.removeListener(\"transactionHash\", handlers.hash);\n  },\n  confirmation: function confirmation(context, number, receipt) {\n    context.promiEvent.eventEmitter.emit(\"confirmation\", number, receipt); // Per web3: initial confirmation index is 0\n\n    if (number === handlers.maxConfirmations + 1) {\n      this.removeListener(\"confirmation\", handlers.confirmation);\n    }\n  },\n\n  /**\n   * Receipt event handler. This handler decodes the event logs, re-emits the receipt,\n   * and (for method calls only) resolves/rejects the promiEvent with the receipt.\n   * @param  {Object} context   execution state\n   * @param  {Object} receipt   transaction receipt\n   */\n  receipt: function () {\n    var _receipt2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(context, _receipt) {\n      var reason, error;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              // keep around the raw (not decoded) logs in the raw logs field as a\n              // stopgap until we can get the ABI for all events, not just the current\n              // contract\n              _receipt.rawLogs = _receipt.logs; // Decode logs, use as receipt.logs for ease of use.\n\n              _context.prev = 1;\n              _receipt.logs = _receipt.logs ? Utils.decodeLogs.call(context.contract, _receipt.logs) : [];\n              _context.next = 8;\n              break;\n\n            case 5:\n              _context.prev = 5;\n              _context.t0 = _context[\"catch\"](1);\n              return _context.abrupt(\"return\", context.promiEvent.reject(_context.t0));\n\n            case 8:\n              // Emit receipt\n              context.promiEvent.eventEmitter.emit(\"receipt\", _receipt); // .new(): Exit early. We need the promiEvent to resolve a contract instance.\n\n              if (!context.onlyEmitReceipt) {\n                _context.next = 12;\n                break;\n              }\n\n              context.receipt = _receipt;\n              return _context.abrupt(\"return\");\n\n            case 12:\n              if (!(_receipt.status !== undefined && !_receipt.status)) {\n                _context.next = 18;\n                break;\n              }\n\n              _context.next = 15;\n              return Reason.get(context.params, context.contract.web3);\n\n            case 15:\n              reason = _context.sent;\n              error = new StatusError(context.params, _receipt.transactionHash, _receipt, reason);\n              return _context.abrupt(\"return\", context.promiEvent.reject(error));\n\n            case 18:\n              // This object has some duplicate data but is backward compatible.\n              context.promiEvent.resolve({\n                tx: _receipt.transactionHash,\n                receipt: _receipt,\n                logs: _receipt.logs\n              });\n              this.removeListener(\"receipt\", handlers.receipt);\n\n            case 20:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, this, [[1, 5]]);\n    }));\n\n    function receipt(_x, _x2) {\n      return _receipt2.apply(this, arguments);\n    }\n\n    return receipt;\n  }()\n};\nmodule.exports = handlers;","map":{"version":3,"sources":["/home/azen/Documents/blockstudio-main/App/node_modules/truffle-contract/lib/handlers.js"],"names":["debug","require","StatusError","Utils","Reason","handlers","maxConfirmations","defaultTimeoutBlocks","timeoutMessage","ignoreTimeoutError","context","error","timedOut","message","includes","shouldWait","contract","timeoutBlocks","setup","emitter","on","bind","hash","confirmation","receipt","promiEvent","eventEmitter","emit","removeListener","transactionHash","number","rawLogs","logs","decodeLogs","call","reject","onlyEmitReceipt","status","undefined","get","params","web3","reason","resolve","tx","module","exports"],"mappings":";;;;AAAA,IAAMA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAAP,CAAiB,mBAAjB,CAAd,C,CAAqD;;;AACrD,IAAIC,WAAW,GAAGD,OAAO,CAAC,eAAD,CAAzB;;AACA,IAAIE,KAAK,GAAGF,OAAO,CAAC,SAAD,CAAnB;;AACA,IAAIG,MAAM,GAAGH,OAAO,CAAC,UAAD,CAApB;AAEA;AACA;AACA;;;AACA,IAAII,QAAQ,GAAG;AACb;AAEAC,EAAAA,gBAAgB,EAAE,EAHL;AAGS;AACtBC,EAAAA,oBAAoB,EAAE,EAJT;AAIa;AAC1BC,EAAAA,cAAc,EAAE,WALH;AAKgB;AAE7B;;AAEA;AACF;AACA;AACA;AACA;AACA;AACEC,EAAAA,kBAAkB,EAAE,4BAASC,OAAT,EAAkBC,KAAlB,EAAyB;AAC3C,QAAIC,QAAQ,GACVD,KAAK,CAACE,OAAN,IAAiBF,KAAK,CAACE,OAAN,CAAcC,QAAd,CAAuBT,QAAQ,CAACG,cAAhC,CADnB;AAGA,QAAIO,UAAU,GACZL,OAAO,CAACM,QAAR,IACAN,OAAO,CAACM,QAAR,CAAiBC,aADjB,IAEAP,OAAO,CAACM,QAAR,CAAiBC,aAAjB,GAAiCZ,QAAQ,CAACE,oBAH5C;AAKA,WAAOK,QAAQ,IAAIG,UAAnB;AACD,GAzBY;;AA2Bb;AACF;AACA;AACA;AACA;AACEG,EAAAA,KAAK,EAAE,eAASC,OAAT,EAAkBT,OAAlB,EAA2B;AAChCS,IAAAA,OAAO,CAACC,EAAR,CAAW,OAAX,EAAoBf,QAAQ,CAACM,KAAT,CAAeU,IAAf,CAAoBF,OAApB,EAA6BT,OAA7B,CAApB;AACAS,IAAAA,OAAO,CAACC,EAAR,CAAW,iBAAX,EAA8Bf,QAAQ,CAACiB,IAAT,CAAcD,IAAd,CAAmBF,OAAnB,EAA4BT,OAA5B,CAA9B;AACAS,IAAAA,OAAO,CAACC,EAAR,CAAW,cAAX,EAA2Bf,QAAQ,CAACkB,YAAT,CAAsBF,IAAtB,CAA2BF,OAA3B,EAAoCT,OAApC,CAA3B;AACAS,IAAAA,OAAO,CAACC,EAAR,CAAW,SAAX,EAAsBf,QAAQ,CAACmB,OAAT,CAAiBH,IAAjB,CAAsBF,OAAtB,EAA+BT,OAA/B,CAAtB;AACD,GArCY;AAuCb;;AACA;AACF;AACA;AACA;AACA;AACA;AACEC,EAAAA,KAAK,EAAE,eAASD,OAAT,EAAkBC,MAAlB,EAAyB;AAC9B,QAAI,CAACN,QAAQ,CAACI,kBAAT,CAA4BC,OAA5B,EAAqCC,MAArC,CAAL,EAAkD;AAChDD,MAAAA,OAAO,CAACe,UAAR,CAAmBC,YAAnB,CAAgCC,IAAhC,CAAqC,OAArC,EAA8ChB,MAA9C;AACA,WAAKiB,cAAL,CAAoB,OAApB,EAA6BvB,QAAQ,CAACM,KAAtC;AACD;AACF,GAnDY;;AAqDb;AACF;AACA;AACA;AACA;AACA;AACEW,EAAAA,IAAI,EAAE,cAASZ,OAAT,EAAkBY,KAAlB,EAAwB;AAC5BZ,IAAAA,OAAO,CAACmB,eAAR,GAA0BP,KAA1B;AACAZ,IAAAA,OAAO,CAACe,UAAR,CAAmBC,YAAnB,CAAgCC,IAAhC,CAAqC,iBAArC,EAAwDL,KAAxD;AACA,SAAKM,cAAL,CAAoB,iBAApB,EAAuCvB,QAAQ,CAACiB,IAAhD;AACD,GA/DY;AAiEbC,EAAAA,YAAY,EAAE,sBAASb,OAAT,EAAkBoB,MAAlB,EAA0BN,OAA1B,EAAmC;AAC/Cd,IAAAA,OAAO,CAACe,UAAR,CAAmBC,YAAnB,CAAgCC,IAAhC,CAAqC,cAArC,EAAqDG,MAArD,EAA6DN,OAA7D,EAD+C,CAG/C;;AACA,QAAIM,MAAM,KAAKzB,QAAQ,CAACC,gBAAT,GAA4B,CAA3C,EAA8C;AAC5C,WAAKsB,cAAL,CAAoB,cAApB,EAAoCvB,QAAQ,CAACkB,YAA7C;AACD;AACF,GAxEY;;AA0Eb;AACF;AACA;AACA;AACA;AACA;AACEC,EAAAA,OAAO;AAAA,6EAAE,iBAAed,OAAf,EAAwBc,QAAxB;AAAA;AAAA;AAAA;AAAA;AAAA;AACP;AACA;AACA;AACAA,cAAAA,QAAO,CAACO,OAAR,GAAkBP,QAAO,CAACQ,IAA1B,CAJO,CAMP;;AANO;AAQLR,cAAAA,QAAO,CAACQ,IAAR,GAAeR,QAAO,CAACQ,IAAR,GACX7B,KAAK,CAAC8B,UAAN,CAAiBC,IAAjB,CAAsBxB,OAAO,CAACM,QAA9B,EAAwCQ,QAAO,CAACQ,IAAhD,CADW,GAEX,EAFJ;AARK;AAAA;;AAAA;AAAA;AAAA;AAAA,+CAYEtB,OAAO,CAACe,UAAR,CAAmBU,MAAnB,aAZF;;AAAA;AAeP;AACAzB,cAAAA,OAAO,CAACe,UAAR,CAAmBC,YAAnB,CAAgCC,IAAhC,CAAqC,SAArC,EAAgDH,QAAhD,EAhBO,CAkBP;;AAlBO,mBAmBHd,OAAO,CAAC0B,eAnBL;AAAA;AAAA;AAAA;;AAoBL1B,cAAAA,OAAO,CAACc,OAAR,GAAkBA,QAAlB;AApBK;;AAAA;AAAA,oBAyBHA,QAAO,CAACa,MAAR,KAAmBC,SAAnB,IAAgC,CAACd,QAAO,CAACa,MAzBtC;AAAA;AAAA;AAAA;;AAAA;AAAA,qBA0BcjC,MAAM,CAACmC,GAAP,CAAW7B,OAAO,CAAC8B,MAAnB,EAA2B9B,OAAO,CAACM,QAAR,CAAiByB,IAA5C,CA1Bd;;AAAA;AA0BDC,cAAAA,MA1BC;AA4BD/B,cAAAA,KA5BC,GA4BO,IAAIT,WAAJ,CACVQ,OAAO,CAAC8B,MADE,EAEVhB,QAAO,CAACK,eAFE,EAGVL,QAHU,EAIVkB,MAJU,CA5BP;AAAA,+CAmCEhC,OAAO,CAACe,UAAR,CAAmBU,MAAnB,CAA0BxB,KAA1B,CAnCF;;AAAA;AAsCP;AACAD,cAAAA,OAAO,CAACe,UAAR,CAAmBkB,OAAnB,CAA2B;AACzBC,gBAAAA,EAAE,EAAEpB,QAAO,CAACK,eADa;AAEzBL,gBAAAA,OAAO,EAAEA,QAFgB;AAGzBQ,gBAAAA,IAAI,EAAER,QAAO,CAACQ;AAHW,eAA3B;AAMA,mBAAKJ,cAAL,CAAoB,SAApB,EAA+BvB,QAAQ,CAACmB,OAAxC;;AA7CO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAhFM,CAAf;AAiIAqB,MAAM,CAACC,OAAP,GAAiBzC,QAAjB","sourcesContent":["const debug = require(\"debug\")(\"contract:handlers\"); // eslint-disable-line no-unused-vars\nvar StatusError = require(\"./statuserror\");\nvar Utils = require(\"./utils\");\nvar Reason = require(\"./reason\");\n\n/*\n  Handlers for events emitted by `send` / `call` etc.\n */\nvar handlers = {\n  // ----------------------------------- Constants -------------------------------------------------\n\n  maxConfirmations: 24, // Maximum number of confirmation web3 emits\n  defaultTimeoutBlocks: 50, // Maximum number of blocks web3 will wait before abandoning tx\n  timeoutMessage: \"50 blocks\", // Substring of web3 timeout error.\n\n  // -----------------------------------  Helpers --------------------------------------------------\n\n  /**\n   * Parses error message and determines if we should squash block timeout errors at user's request.\n   * @param  {Object} context execution state\n   * @param  {Object} error   error\n   * @return {Boolean}\n   */\n  ignoreTimeoutError: function(context, error) {\n    var timedOut =\n      error.message && error.message.includes(handlers.timeoutMessage);\n\n    var shouldWait =\n      context.contract &&\n      context.contract.timeoutBlocks &&\n      context.contract.timeoutBlocks > handlers.defaultTimeoutBlocks;\n\n    return timedOut && shouldWait;\n  },\n\n  /**\n   * Attaches Truffle specific handlers to all of the events emitted by a web3 method.\n   * @param {Object}       context  execution state\n   * @param {PromiEvent}   emitter  promiEvent returned by a web3 method call\n   */\n  setup: function(emitter, context) {\n    emitter.on(\"error\", handlers.error.bind(emitter, context));\n    emitter.on(\"transactionHash\", handlers.hash.bind(emitter, context));\n    emitter.on(\"confirmation\", handlers.confirmation.bind(emitter, context));\n    emitter.on(\"receipt\", handlers.receipt.bind(emitter, context));\n  },\n\n  // -----------------------------------  Handlers -------------------------------------------------\n  /**\n   * Error event handler. Emits error unless error is block timeout and user has\n   * specified we should wait longer\n   * @param  {Object} context   execution state\n   * @param  {Object} error     error\n   */\n  error: function(context, error) {\n    if (!handlers.ignoreTimeoutError(context, error)) {\n      context.promiEvent.eventEmitter.emit(\"error\", error);\n      this.removeListener(\"error\", handlers.error);\n    }\n  },\n\n  /**\n   * Transaction hash event handler. Attaches the hash to the context object\n   * so it can be attached to the contract instance after a deployment resolves.\n   * @param  {Object} context   execution state\n   * @param  {String} hash      transaction hash\n   */\n  hash: function(context, hash) {\n    context.transactionHash = hash;\n    context.promiEvent.eventEmitter.emit(\"transactionHash\", hash);\n    this.removeListener(\"transactionHash\", handlers.hash);\n  },\n\n  confirmation: function(context, number, receipt) {\n    context.promiEvent.eventEmitter.emit(\"confirmation\", number, receipt);\n\n    // Per web3: initial confirmation index is 0\n    if (number === handlers.maxConfirmations + 1) {\n      this.removeListener(\"confirmation\", handlers.confirmation);\n    }\n  },\n\n  /**\n   * Receipt event handler. This handler decodes the event logs, re-emits the receipt,\n   * and (for method calls only) resolves/rejects the promiEvent with the receipt.\n   * @param  {Object} context   execution state\n   * @param  {Object} receipt   transaction receipt\n   */\n  receipt: async function(context, receipt) {\n    // keep around the raw (not decoded) logs in the raw logs field as a\n    // stopgap until we can get the ABI for all events, not just the current\n    // contract\n    receipt.rawLogs = receipt.logs;\n\n    // Decode logs, use as receipt.logs for ease of use.\n    try {\n      receipt.logs = receipt.logs\n        ? Utils.decodeLogs.call(context.contract, receipt.logs)\n        : [];\n    } catch (error) {\n      return context.promiEvent.reject(error);\n    }\n\n    // Emit receipt\n    context.promiEvent.eventEmitter.emit(\"receipt\", receipt);\n\n    // .new(): Exit early. We need the promiEvent to resolve a contract instance.\n    if (context.onlyEmitReceipt) {\n      context.receipt = receipt;\n      return;\n    }\n\n    // .method(): resolve/reject receipt in handler\n    if (receipt.status !== undefined && !receipt.status) {\n      var reason = await Reason.get(context.params, context.contract.web3);\n\n      var error = new StatusError(\n        context.params,\n        receipt.transactionHash,\n        receipt,\n        reason\n      );\n\n      return context.promiEvent.reject(error);\n    }\n\n    // This object has some duplicate data but is backward compatible.\n    context.promiEvent.resolve({\n      tx: receipt.transactionHash,\n      receipt: receipt,\n      logs: receipt.logs\n    });\n\n    this.removeListener(\"receipt\", handlers.receipt);\n  }\n};\n\nmodule.exports = handlers;\n"]},"metadata":{},"sourceType":"script"}