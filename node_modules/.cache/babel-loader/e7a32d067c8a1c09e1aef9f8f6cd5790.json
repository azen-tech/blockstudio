{"ast":null,"code":"var _regeneratorRuntime = require(\"/home/azen/Documents/blockstudio-main/App/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/azen/Documents/blockstudio-main/App/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar Reason = require('./reason');\n\nvar handlers = require('./handlers');\n\nvar override = {\n  timeoutMessage: 'not mined within',\n  // Substring of timeout err fired by web3\n  defaultMaxBlocks: 50,\n  // Max # of blocks web3 will wait for a tx\n  pollingInterval: 1000,\n\n  /**\n   * Attempts to extract receipt object from Web3 error message\n   * @param  {Object} message       web3 error\n   * @return {Object|undefined} receipt\n   */\n  extractReceipt: function extractReceipt(message) {\n    var hasReceipt = message && message.includes('{');\n    message.includes('}');\n\n    if (hasReceipt) {\n      var receiptString = '{' + message.split('{')[1].trim();\n\n      try {\n        return JSON.parse(receiptString);\n      } catch (err) {// ignore\n      }\n    }\n  },\n\n  /**\n   * Fired after web3 ceases to support subscriptions if user has specified\n   * a higher block wait time than web3's 50 blocks limit. Opens a subscription to listen\n   * for new blocks and begins evaluating whether block height has reached the user\n   * defined timeout threshhold. Resolves either a contract instance or a transaction receipt.\n   *\n   * @param  {Object} context execution state\n   * @param  {Object} err     error\n   */\n  start: function () {\n    var _start = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(context, web3Error) {\n      var constructor, blockNumber, currentBlock, maxBlocks, timedOut, shouldWait, receipt, reason, listener, currentPollingBlock, pollID;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              constructor = this;\n              blockNumber = null;\n              currentBlock = override.defaultMaxBlocks;\n              maxBlocks = constructor.timeoutBlocks;\n              timedOut = web3Error.message && web3Error.message.includes(override.timeoutMessage);\n              shouldWait = maxBlocks > currentBlock; // Reject after attempting to get reason string if we shouldn't be waiting.\n\n              if (!(!timedOut || !shouldWait)) {\n                _context2.next = 17;\n                break;\n              }\n\n              // We might have been routed here in web3 >= beta.34 by their own status check\n              // error. We want to extract the receipt, emit a receipt event\n              // and reject it ourselves.\n              receipt = override.extractReceipt(web3Error.message);\n\n              if (!receipt) {\n                _context2.next = 12;\n                break;\n              }\n\n              _context2.next = 11;\n              return handlers.receipt(context, receipt);\n\n            case 11:\n              return _context2.abrupt(\"return\");\n\n            case 12:\n              _context2.next = 14;\n              return Reason.get(context.params, constructor.web3);\n\n            case 14:\n              reason = _context2.sent;\n\n              if (reason) {\n                web3Error.reason = reason;\n                web3Error.message += \" -- Reason given: \".concat(reason, \".\");\n              }\n\n              return _context2.abrupt(\"return\", context.promiEvent.reject(web3Error));\n\n            case 17:\n              // This will run every block from now until contract.timeoutBlocks\n              listener = function listener(pollID) {\n                var self = this;\n                currentBlock++;\n\n                if (currentBlock > constructor.timeoutBlocks) {\n                  clearInterval(pollID);\n                  return;\n                }\n\n                constructor.web3.eth.getTransactionReceipt(context.transactionHash).then(function (result) {\n                  if (!result) return;\n                  result.contractAddress ? constructor.at(result.contractAddress).then(context.promiEvent.resolve).catch(context.promiEvent.reject) : constructor.promiEvent.resolve(result);\n                }).catch(function (err) {\n                  clearInterval(pollID);\n                  context.promiEvent.reject(err);\n                });\n              }; // Start polling\n\n\n              _context2.next = 20;\n              return constructor.web3.eth.getBlockNumber();\n\n            case 20:\n              currentPollingBlock = _context2.sent;\n              pollID = setInterval( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n                var newBlock;\n                return _regeneratorRuntime.wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        _context.next = 2;\n                        return constructor.web3.eth.getBlockNumber();\n\n                      case 2:\n                        newBlock = _context.sent;\n\n                        if (newBlock > currentPollingBlock) {\n                          currentPollingBlock = newBlock;\n                          listener(pollID);\n                        }\n\n                      case 4:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee);\n              })), override.pollingInterval);\n\n            case 22:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, this);\n    }));\n\n    function start(_x, _x2) {\n      return _start.apply(this, arguments);\n    }\n\n    return start;\n  }()\n};\nmodule.exports = override;","map":{"version":3,"sources":["/home/azen/Documents/blockstudio-main/App/node_modules/truffle-contract/lib/override.js"],"names":["Reason","require","handlers","override","timeoutMessage","defaultMaxBlocks","pollingInterval","extractReceipt","message","hasReceipt","includes","receiptString","split","trim","JSON","parse","err","start","context","web3Error","constructor","blockNumber","currentBlock","maxBlocks","timeoutBlocks","timedOut","shouldWait","receipt","get","params","web3","reason","promiEvent","reject","listener","pollID","self","clearInterval","eth","getTransactionReceipt","transactionHash","then","result","contractAddress","at","resolve","catch","getBlockNumber","currentPollingBlock","setInterval","newBlock","module","exports"],"mappings":"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","sourcesContent":["var Reason = require('./reason');\nvar handlers = require('./handlers');\n\nvar override = {\n\n  timeoutMessage: 'not mined within', // Substring of timeout err fired by web3\n  defaultMaxBlocks: 50,               // Max # of blocks web3 will wait for a tx\n  pollingInterval: 1000,\n\n  /**\n   * Attempts to extract receipt object from Web3 error message\n   * @param  {Object} message       web3 error\n   * @return {Object|undefined} receipt\n   */\n  extractReceipt(message){\n    const hasReceipt = message &&\n                       message.includes('{');\n                       message.includes('}');\n\n    if (hasReceipt){\n      const receiptString =  '{' + message.split('{')[1].trim();\n      try {\n        return JSON.parse(receiptString);\n      } catch (err){\n        // ignore\n      }\n    }\n  },\n\n  /**\n   * Fired after web3 ceases to support subscriptions if user has specified\n   * a higher block wait time than web3's 50 blocks limit. Opens a subscription to listen\n   * for new blocks and begins evaluating whether block height has reached the user\n   * defined timeout threshhold. Resolves either a contract instance or a transaction receipt.\n   *\n   * @param  {Object} context execution state\n   * @param  {Object} err     error\n   */\n  start: async function(context, web3Error){\n    var constructor = this;\n    var blockNumber = null;\n    var currentBlock = override.defaultMaxBlocks;\n    var maxBlocks = constructor.timeoutBlocks;\n\n    var timedOut = web3Error.message && web3Error.message.includes(override.timeoutMessage);\n    var shouldWait = maxBlocks > currentBlock;\n\n    // Reject after attempting to get reason string if we shouldn't be waiting.\n    if (!timedOut || !shouldWait){\n\n      // We might have been routed here in web3 >= beta.34 by their own status check\n      // error. We want to extract the receipt, emit a receipt event\n      // and reject it ourselves.\n      var receipt = override.extractReceipt(web3Error.message);\n      if (receipt){\n        await handlers.receipt(context, receipt);\n        return;\n      }\n\n      // This will run if there's a reason and no status field\n      // e.g: revert with reason ganache-cli --vmErrorsOnRPCResponse=true\n      var reason = await Reason.get(context.params, constructor.web3);\n      if (reason) {\n        web3Error.reason = reason;\n        web3Error.message += ` -- Reason given: ${reason}.`;\n      }\n\n      return context.promiEvent.reject(web3Error);\n    }\n\n    // This will run every block from now until contract.timeoutBlocks\n    var listener = function(pollID){\n      var self = this;\n      currentBlock++;\n\n      if (currentBlock > constructor.timeoutBlocks){\n        clearInterval(pollID);\n        return;\n      }\n\n      constructor.web3.eth.getTransactionReceipt(context.transactionHash)\n        .then(result => {\n          if (!result) return;\n\n          (result.contractAddress)\n            ? constructor\n                .at(result.contractAddress)\n                .then(context.promiEvent.resolve)\n                .catch(context.promiEvent.reject)\n\n            : constructor.promiEvent.resolve(result);\n\n        })\n        .catch(err => {\n          clearInterval(pollID);\n          context.promiEvent.reject(err);\n        });\n    };\n\n    // Start polling\n    let currentPollingBlock = await constructor.web3.eth.getBlockNumber();\n\n    const pollID = setInterval(async() => {\n      const newBlock = await constructor.web3.eth.getBlockNumber();\n\n      if(newBlock > currentPollingBlock){\n        currentPollingBlock = newBlock;\n        listener(pollID);\n      }\n    }, override.pollingInterval);\n  },\n};\n\nmodule.exports = override;\n"]},"metadata":{},"sourceType":"script"}